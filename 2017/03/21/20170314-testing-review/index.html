<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>dev notes</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/font_859455_eaq7v6w8ktj.css">
</head>

<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link">
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">Frank Gutierrez's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">testing review</h2>
            <div class="post-meta">
                <span class="post-time">2017-03-21</span>
                
                <span class="post-visit"> visited：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">TOC</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Eventbrite-React-Testing-Best-Practices"><span class="toc-text">Eventbrite React Testing Best Practices</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-environment"><span class="toc-text">Testing environment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-philosophy"><span class="toc-text">Testing philosophy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-a-test-case"><span class="toc-text">Writing a test case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-nodes"><span class="toc-text">Finding nodes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding-components"><span class="toc-text">Finding components</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-existence"><span class="toc-text">Testing existence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assertion-helpers"><span class="toc-text">Assertion helpers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Types-of-renderers"><span class="toc-text">Types of renderers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-render"><span class="toc-text">Testing render</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-events"><span class="toc-text">Testing events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-state"><span class="toc-text">Testing state</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-updated-props"><span class="toc-text">Testing updated props</span></a></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">back to top</a>
    </div>
</div>

        <div class="post-content">
            <p>This is a succint version of <a href="https://goo.gl/cl4b1P" target="_blank" rel="noopener">Eventbrite React Testing Best Practices</a></p>
<h1 id="Eventbrite-React-Testing-Best-Practices"><a href="#Eventbrite-React-Testing-Best-Practices" class="headerlink" title="Eventbrite React Testing Best Practices"></a>Eventbrite React Testing Best Practices</h1><h2 id="Testing-environment"><a href="#Testing-environment" class="headerlink" title="Testing environment"></a>Testing environment</h2><ul>
<li>jest, enzyme, jest-enzyme</li>
</ul>
<h2 id="Testing-philosophy"><a href="#Testing-philosophy" class="headerlink" title="Testing philosophy"></a>Testing philosophy</h2><p>Test the public interface.</p>
<ul>
<li>public input: props</li>
<li>public output: elements rendered, callbacks invoked.</li>
</ul>
<p>render with various prop configs, assert what is rendered and called back.</p>
<h2 id="Writing-a-test-case"><a href="#Writing-a-test-case" class="headerlink" title="Writing a test case"></a>Writing a test case</h2><ul>
<li>use arrow functions</li>
<li>no beforeEach afterEach</li>
</ul>
<h2 id="Finding-nodes"><a href="#Finding-nodes" class="headerlink" title="Finding nodes"></a>Finding nodes</h2><ul>
<li>sprinkle: data-spec=”reset-button”</li>
<li>use <code>getSpecWrapper</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/unitTest.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DATA_SPEC_ATTRIBUTE_NAME = <span class="string">'data-spec'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Finds all instances of components in the rendered `componentWrapper` that are DOM components</span></span><br><span class="line"><span class="comment">* with the `data-spec` attribute matching `name`.</span></span><br><span class="line"><span class="comment">* @param &#123;ReactWrapper&#125; componentWrapper - Rendered componentWrapper (result of mount, shallow, or render)</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; specName - Name of `data-spec` attribute value to find</span></span><br><span class="line"><span class="comment">* @param &#123;string|Function&#125; typeFilter - (Optional) Expected type of the wrappers (defaults to all HTML tags)</span></span><br><span class="line"><span class="comment">* @returns &#123;ReactComponent[]&#125; All matching DOM components</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getSpecWrapper = <span class="function">(<span class="params">componentWrapper, specName, typeFilter</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> specWrappers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeFilter) &#123;</span><br><span class="line">        specWrappers = componentWrapper.find(<span class="string">`[<span class="subst">$&#123;DATA_SPEC_ATTRIBUTE_NAME&#125;</span>="<span class="subst">$&#123;specName&#125;</span>"]`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        specWrappers = componentWrapper.findWhere(<span class="function">(<span class="params">wrapper</span>) =&gt;</span> (</span><br><span class="line">            wrapper.prop(DATA_SPEC_ATTRIBUTE_NAME) === specName &amp;&amp; wrapper.type() === typeFilter</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> specWrappers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Finding-components"><a href="#Finding-components" class="headerlink" title="Finding components"></a>Finding components</h2><ul>
<li>use <code>getSpecWrapper</code></li>
</ul>
<p>The key in the “good” example is the third parameter passed to getSpecWrapper. By default getSpecWrapper will try to find a node with the specified data-spec. But if you specify the component class (Checkbox in this case), it’ll return a reference to the component wrapper.</p>
<h2 id="Testing-existence"><a href="#Testing-existence" class="headerlink" title="Testing existence"></a>Testing existence</h2><p><strong>testing node existence</strong></p>
<p>To find nodes you use the <code>getSpecWrapper</code> helper and use the <code>jest-enzyme</code> <code>.toBePresent</code> and <code>.toBeEmpty</code> assertion matchers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that node exists (doesn't throw an Error)</span></span><br><span class="line"><span class="xml">expect(wrapper).toBePresent();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that node doesn't exist (throws an Error)</span></span><br><span class="line"><span class="xml">expect(wrapper).toBeEmpty();</span></span><br></pre></td></tr></table></figure>
<p><strong>testing component existence</strong></p>
<p>Typically, you’ll find components by using Enzyme’s <code>find</code> method which returns an an Enzyme ReactWrapper and the <code>jest-enzyme</code> <code>.toBePresent</code> and <code>.toBeEmpty</code> assertion matchers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Select</span> <span class="attr">values</span>=<span class="string">&#123;dummyValues&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">let selectOptionWrappers = wrapper.find(SelectOption);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that there are no found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toBeEmpty();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that there are more than zero found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toBePresent();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert there to be a specific number of found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toHaveLength(dummyValues.length);</span></span><br></pre></td></tr></table></figure>
<h2 id="Assertion-helpers"><a href="#Assertion-helpers" class="headerlink" title="Assertion helpers"></a>Assertion helpers</h2><p>Whenever possible, use jest-enzyme assertion helpers in favor of the normal assertion helpers that just come with jest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// good (leverages `.prop` from `jest-enzyme`)</span><br><span class="line">it(&apos;should render a checked checkbox if it is selected&apos;, () =&gt; &#123;</span><br><span class="line">    let wrapper = mount(&lt;Component isSelected=&#123;true&#125; /&gt;);</span><br><span class="line">    let checkboxWrapper = wrapper.find(Checkbox);</span><br><span class="line"></span><br><span class="line">    expect(checkboxWrapper).toHaveProp(&apos;isChecked&apos;, true);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using good assertions improves error messages!!</p>
</blockquote>
<h2 id="Types-of-renderers"><a href="#Types-of-renderers" class="headerlink" title="Types of renderers"></a>Types of renderers</h2><blockquote>
<p>Eventbrite uses <code>mount</code> for rendering all components when testing.</p>
</blockquote>
<ul>
<li>The win is consistency</li>
<li>The lose is performance</li>
</ul>
<p>Eventbrite understands the performance impact.</p>
<h2 id="Testing-render"><a href="#Testing-render" class="headerlink" title="Testing render"></a>Testing render</h2><ul>
<li>Do not test the child components (they already have tests)</li>
</ul>
<p>The easiest way to test HTML elements and their attributes, is to use Jest snapshots:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">it(<span class="string">'includes the disabled CSS class when `isDisabled` is `true`'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> <span class="attr">isDisabled</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the current render matches the saved snapshot</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>While snapshot testing is very simple, that simplicity comes at a cost. The initial snapshot file is generated the first time the test is run, so you need to visually inspect that the generated snapshot is correct, otherwise you could be saving a bad test case. Furthermore, the snapshot does not convey the intent of the test so you need to have a very verbose/descriptive test case title (the it()).</p>
<p>Also because we use <code>mount</code> for rendering, the entire component tree is in the snapshot, including any helper components, higher-order components, etc. The larger the component, the larger a snapshot will be.  As such, you should use snapshot testing sparingly and instead test that child components are rendered and get the appropriate props.</p>
<p>Lastly, since snapshot files are saved to disk, running the tests are slower than traditional means of unit testing.</p>
<h2 id="Testing-events"><a href="#Testing-events" class="headerlink" title="Testing events"></a>Testing events</h2><p>As mentioned in our <code>Testing philosophy</code>, part of the output of your component are the callback handlers it invokes. These event callbacks are functions passed as props to your component and need to be tested.</p>
<ul>
<li>trigger the events that in turn will invoke the callback handler</li>
</ul>
<p><strong>test events triggered by the DOM</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'properly fires `onChange` when input changes'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> onChange = jest.fn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass mock function to component as `onChange` prop</span></span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let inputWrapper = getSpecWrapper(wrapper, 'text-input');</span></span><br><span class="line"><span class="xml">    let inputValue = 'Here is a value';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // Create a fake event with the properties needed by the component</span></span><br><span class="line"><span class="xml">    let mockEvent = &#123;</span></span><br><span class="line"><span class="xml">        target: &#123;</span></span><br><span class="line"><span class="xml">            value: inputValue</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate onChange event on input DOM</span></span><br><span class="line"><span class="xml">    inputWrapper.simulate('change', mockEvent);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the stubbed function was called with the</span></span><br><span class="line"><span class="xml">    // expected value</span></span><br><span class="line"><span class="xml">    expect(onChange).toHaveBeenCalledWith(inputValue);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><strong>Testing events triggered by child components</strong></p>
<p>More than likely instead of your component adding event handlers directly to DOM nodes, it will be adding handlers to child components. Therefore instead of simulating a DOM event, simulate the child component’s event handler being invoked.</p>
<p>Let’s say you have an <code>AutocompleteField</code> component that has a child <code>TextInput</code>. The <code>AutocompleteField</code> has an <code>onChange</code> prop that is invoked whenever its child <code>TextInput</code>‘s <code>onChange</code> event is invoked. The <code>AutocompleteField</code>‘s <code>onChange</code> prop also passes the current input value. The test case would be set up like:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'properly fires `onChange` when input changes'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> onChange = jest.fn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass stubbed function to component as `onChange` prop</span></span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">AutocompleteField</span> <span class="attr">suggestions</span>=<span class="string">&#123;[]&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let textInputWrapper = wrapper.find(TextInput);</span></span><br><span class="line"><span class="xml">    let inputValue = 'Here is a value';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // We don't want to make any assumptions about the markup of `TextInput`. The</span></span><br><span class="line"><span class="xml">    // `AutocompleteField` component handles `onChange` of `TextInput`, so all we need to</span></span><br><span class="line"><span class="xml">    // do is call the prop directly like `TextInput` would and ensure we get the appropriate</span></span><br><span class="line"><span class="xml">    // value</span></span><br><span class="line"><span class="xml">    textInputWrapper.prop('onChange')(inputValue);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the stubbed function was called with the</span></span><br><span class="line"><span class="xml">    // expected value</span></span><br><span class="line"><span class="xml">    expect(onChange).toHaveBeenCalledWith(inputValue);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>The test case above uses <code>jest.fn()</code> to create a mock function. The mock is passed as the AutocompleteField component’s <code>onChange</code> prop so that we can make assertions on it at the end. After finding a reference to the TextInput, we simulate how TextInput would invoke its <code>onChange</code> callback prop. We get a reference to the prop using Enzyme’s .prop helper and call the function with the <code>inputValue</code>. This exactly how <code>TextInput</code> would call it when its DOM input field changes. However, because we don’t want to make any assumptions about the markup of <code>TextInput</code> we simulate its <code>onChange</code> prop instead of digging into it in order to simulate its DOM.</p>
<p>Invoking the <code>onChange</code> prop will ultimately call our <code>onChange</code> with the value. Therefore, our assertion is that <code>onChange</code> was not only called, but also called with the expected input value. This assertion leverages the <code>.toHaveBeenCalledWith</code> assertion helper from <code>jest-enzyme</code>.</p>
<h2 id="Testing-state"><a href="#Testing-state" class="headerlink" title="Testing state"></a>Testing state</h2><ul>
<li>do not test the state of a component, only the public interface.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good (tests internal state *indirectly* via re-rendered markup)</span></span><br><span class="line">it(<span class="string">'toggles active state when checkbox is toggled'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let checkboxWrapper = wrapper.find(Checkbox);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // first assert that by default the active class is *not* present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate toggling the checkbox on by calling its</span></span><br><span class="line"><span class="xml">    // onChange callback handler passing `true` for</span></span><br><span class="line"><span class="xml">    // checked state</span></span><br><span class="line"><span class="xml">    checkboxWrapper.prop('onChange')(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // now assert that the active class *is* present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate toggling the checkbox back off</span></span><br><span class="line"><span class="xml">    checkboxWrapper.prop('onChange')(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // finally assert once again that active class is *not*</span></span><br><span class="line"><span class="xml">    // present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<h2 id="Testing-updated-props"><a href="#Testing-updated-props" class="headerlink" title="Testing updated props"></a>Testing updated props</h2><p>Typically components are stateless, meaning that what is rendered by the component is 100% based upon the props that are based in. In these cases creating a component with initial props when <code>testing render</code> and <code>testing events</code> as explained above should suffice. There shouldn’t be a need to test the re-render of a component receiving new props.</p>
<p>However, when a component leverages internal state and its props are changed, what will be rendered will be based on a combination of those updated props and the existing state. In this case, test that the new markup is as it should be, indirectly verifying that the updated prop(s) either have or have not overridden the existing state.</p>
<p>To test the initialValue prop behavior:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;does NOT allow `initialValue` to override existing &lt;input&gt; value&apos;, () =&gt; &#123;</span><br><span class="line">    let initialValue = &apos;react&apos;;</span><br><span class="line">    let newValue = &apos;enzyme&apos;;</span><br><span class="line">    let wrapper = mount(&lt;TextInput initialValue=&#123;initialValue&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">    // ensure that the `initialValue` is properly reflected</span><br><span class="line">    // by checking the &lt;input&gt; node</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">    // update the TextInput&apos;s props</span><br><span class="line">    wrapper.setProps(&#123;value: newValue&#125;);</span><br><span class="line"></span><br><span class="line">    // ensure that the &lt;input&gt; node&apos;s value hasn&apos;t changed</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To test the value prop behavior:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;DOES allow `value` to override existing &lt;input&gt; value&apos;, () =&gt; &#123;</span><br><span class="line">    let initialValue = &apos;react&apos;;</span><br><span class="line">    let newValue = &apos;enzyme&apos;;</span><br><span class="line">    let wrapper = mount(&lt;TextInput initialValue=&#123;initialValue&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">    // ensure that the `initialValue` is properly reflected</span><br><span class="line">    // by checking the &lt;input&gt; node</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">    // update the TextInput&apos;s props</span><br><span class="line">    wrapper.setProps(&#123;value: newValue&#125;);</span><br><span class="line"></span><br><span class="line">    // ensure that the &lt;input&gt; node&apos;s value has changed</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The key to passing new props to the existing TextInput component is the <code>setProps</code> helper method. It will cause a re-render, which will allow us to assert that the new markup is as it should be.</p>
</blockquote>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="/tags/reactjs/" title="reactjs">reactjs</a>
            
            <a class="tag" href="/tags/testing/" title="testing">testing</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
            <a class="prev" href="/2017/03/23/20170323-magic-of-mobx/">
                <i class="iconfont icon-prev"></i>
                <span class="nav-default">magic of mobx</span>
                <span class="nav-mobile">Prev</span>
            </a>
        
        
            <a class="next" href="/2017/03/14/20170314-nwb/">
                <span class="nav-default">nwb</span>
                <span class="nav-mobile">Next</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/dearfrankg">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2018
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/dearfrankg">Frank Gutierrez</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
