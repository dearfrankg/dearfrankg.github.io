<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>dev notes</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/font_859455_eaq7v6w8ktj.css">
</head>

<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link">
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">Frank Gutierrez's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2017/03/23/2017/20170323-magic-of-mobx/">magic of mobx</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2017-03-23</span>
                
            </div>
            <div class="post-content">
                
                    <ul>
<li>source: <a href="https://goo.gl/A2e2FN" target="_blank" rel="noopener">Making React reactive: the pursuit of high performing, easily maintainable React apps</a></li>
</ul>
<h2 id="How-to-build-blazing-fast-react-apps"><a href="#How-to-build-blazing-fast-react-apps" class="headerlink" title="How to build blazing fast react apps?"></a>How to build blazing fast react apps?</h2><ul>
<li>draw thousands of inter-related objects with updates and repaints happening in less than 40ms.</li>
<li>react alone will not do the trick.</li>
<li>the search for an elegant solution led to Observables</li>
<li>with the model being Observable and the React components being Observers, <code>only relevant parts of the UI get updated</code>.</li>
</ul>
<h2 id="I-want-proof"><a href="#I-want-proof" class="headerlink" title="I want proof!!"></a>I want proof!!</h2><ul>
<li><a href="https://goo.gl/cVihvw" target="_blank" rel="noopener">Cart with Observables</a></li>
<li><a href="https://goo.gl/MlZdQN" target="_blank" rel="noopener">Cart without Observables</a></li>
</ul>
<p><img src="http://i.imgur.com/cpZx1Lu.png" alt=""></p>
<p>Let’s define our data model:</p>
<blockquote>
<p>Open bullets represent the derived data that should be updated if some other data changes and so should its representation in the UI.</p>
</blockquote>
<p><img src="http://i.imgur.com/hFMjgoG.png" alt=""></p>
<p>So even in this simple model a lot of data is flowing around, and a lot of UI updates are required when stuff changes.</p>
<p>Let’s compile a list of relations</p>
<ul>
<li>article.price changes entry prices</li>
<li>article.price changes cart total</li>
<li>cart.articles changes cart.total</li>
<li>article.name changes article view</li>
<li>article.name changes entry.name</li>
<li>etc, etc, etc</li>
</ul>
<p>The gist of our problem</p>
<ul>
<li>As a developer we don’t want to track this information.</li>
<li>rendering will become slow if we re-render on every data change.</li>
</ul>
<h2 id="It’s-more-fun-if-we-make-it"><a href="#It’s-more-fun-if-we-make-it" class="headerlink" title="It’s more fun if we make it ;)"></a>It’s more fun if we make it ;)</h2><p><strong>Write our <a href="">data model</a> and our <a href="">user interface</a></strong></p>
<ul>
<li>CartView renders cart.total and cart.entries using CartEntryView</li>
<li>An id is provided for each entry</li>
<li>The remove button drops the entry.amount by one and removes the entry when it hits zero</li>
</ul>
<p><strong>Add an observer to each component to settle all the requirements</strong></p>
<p>The observer function did two things:</p>
<ul>
<li>changes the render function into a <code>computed</code> function</li>
<li>the component was registered as an observer of that function which forces a re-render when it becomes stale.</li>
</ul>
<p><strong>When observable data changes only the relevant parts of the UI are updated</strong></p>
<p>These tests confirm that a minimal amount of re-rendering occurs:</p>
<blockquote>
<p>The highlighted area shows the components that re-rendered.<br>The number on the end is an id.</p>
</blockquote>
<ul>
<li><p>rename an article not in the shopping cart</p>
<pre><code>Rendering ArticleView 2
</code></pre></li>
<li><p>add an article to the cart then rename it</p>
<pre><code>Rendering ArticleView 1
Rendering CartEntryView 4
</code></pre></li>
<li><p>add an article to the cart the update its price</p>
<pre><code>Rendering ArticleView 2
Rendering CartTotalView
</code></pre></li>
<li><p>remove it from the cart and update the price again</p>
<pre><code>Rendering ArticleView 1
</code></pre></li>
</ul>
<p><strong>no need to explicitly re-render the children of a component</strong></p>
<p>Each component tracks its own dependencies.</p>
<p>The cart.total can change without re-rendering the cart.entries</p>
<ul>
<li><p>add an article to the cart the update its price</p>
<pre><code>Rendering ArticleView 2
Rendering CartTotalView
</code></pre></li>
</ul>
<h2 id="The-Numbers"><a href="#The-Numbers" class="headerlink" title="The Numbers"></a>The Numbers</h2><p><img src="http://i.imgur.com/o0O4VvY.png" alt=""></p>
<p><img src="http://i.imgur.com/5ekmdcS.png" alt=""></p>
<ul>
<li>Creating: behaves very similar.</li>
<li>Updating: Instead of re-rendering 20,006 components, only 31 components are re-rendered</li>
</ul>
<p><strong>How to Optimize even more</strong></p>
<p>Separating the CartView into CartView and CartTotalView saves us from checking if we need to re-rendering the 10k cart-view items. This drops rendering updates to 60ms!</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>Order of magnitude faster without compromising the maintainability of the code</li>
<li>Optimizing using ImmutableJS would render very fast but much more work on the data model</li>
</ul>
<p>Also immutable data does not help you to keep your calculated values up to date. So with immutable data, changing the name of an article would really fast re-render the ArticleView, but still not invalidate any existing CartEntryViews that refers to the same article.</p>
<p>I strongly advise using controllers or action dispatchers as an abstraction around updating your model data to keep the separation of concerns clear in your project.</p>
<p>Leave the <strong>hard work</strong> of figuring out when and how to update the UI as fast as possible to React and Observables, and focus on the interesting parts of coding :).</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2017/03/21/2017/20170314-testing-review/">testing review</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2017-03-21</span>
                
            </div>
            <div class="post-content">
                
                    <p>This is a succint version of <a href="https://goo.gl/cl4b1P" target="_blank" rel="noopener">Eventbrite React Testing Best Practices</a></p>
<h1 id="Eventbrite-React-Testing-Best-Practices"><a href="#Eventbrite-React-Testing-Best-Practices" class="headerlink" title="Eventbrite React Testing Best Practices"></a>Eventbrite React Testing Best Practices</h1><h2 id="Testing-environment"><a href="#Testing-environment" class="headerlink" title="Testing environment"></a>Testing environment</h2><ul>
<li>jest, enzyme, jest-enzyme</li>
</ul>
<h2 id="Testing-philosophy"><a href="#Testing-philosophy" class="headerlink" title="Testing philosophy"></a>Testing philosophy</h2><p>Test the public interface.</p>
<ul>
<li>public input: props</li>
<li>public output: elements rendered, callbacks invoked.</li>
</ul>
<p>render with various prop configs, assert what is rendered and called back.</p>
<h2 id="Writing-a-test-case"><a href="#Writing-a-test-case" class="headerlink" title="Writing a test case"></a>Writing a test case</h2><ul>
<li>use arrow functions</li>
<li>no beforeEach afterEach</li>
</ul>
<h2 id="Finding-nodes"><a href="#Finding-nodes" class="headerlink" title="Finding nodes"></a>Finding nodes</h2><ul>
<li>sprinkle: data-spec=”reset-button”</li>
<li>use <code>getSpecWrapper</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/unitTest.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DATA_SPEC_ATTRIBUTE_NAME = <span class="string">'data-spec'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Finds all instances of components in the rendered `componentWrapper` that are DOM components</span></span><br><span class="line"><span class="comment">* with the `data-spec` attribute matching `name`.</span></span><br><span class="line"><span class="comment">* @param &#123;ReactWrapper&#125; componentWrapper - Rendered componentWrapper (result of mount, shallow, or render)</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; specName - Name of `data-spec` attribute value to find</span></span><br><span class="line"><span class="comment">* @param &#123;string|Function&#125; typeFilter - (Optional) Expected type of the wrappers (defaults to all HTML tags)</span></span><br><span class="line"><span class="comment">* @returns &#123;ReactComponent[]&#125; All matching DOM components</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getSpecWrapper = <span class="function">(<span class="params">componentWrapper, specName, typeFilter</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> specWrappers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeFilter) &#123;</span><br><span class="line">        specWrappers = componentWrapper.find(<span class="string">`[<span class="subst">$&#123;DATA_SPEC_ATTRIBUTE_NAME&#125;</span>="<span class="subst">$&#123;specName&#125;</span>"]`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        specWrappers = componentWrapper.findWhere(<span class="function">(<span class="params">wrapper</span>) =&gt;</span> (</span><br><span class="line">            wrapper.prop(DATA_SPEC_ATTRIBUTE_NAME) === specName &amp;&amp; wrapper.type() === typeFilter</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> specWrappers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Finding-components"><a href="#Finding-components" class="headerlink" title="Finding components"></a>Finding components</h2><ul>
<li>use <code>getSpecWrapper</code></li>
</ul>
<p>The key in the “good” example is the third parameter passed to getSpecWrapper. By default getSpecWrapper will try to find a node with the specified data-spec. But if you specify the component class (Checkbox in this case), it’ll return a reference to the component wrapper.</p>
<h2 id="Testing-existence"><a href="#Testing-existence" class="headerlink" title="Testing existence"></a>Testing existence</h2><p><strong>testing node existence</strong></p>
<p>To find nodes you use the <code>getSpecWrapper</code> helper and use the <code>jest-enzyme</code> <code>.toBePresent</code> and <code>.toBeEmpty</code> assertion matchers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that node exists (doesn't throw an Error)</span></span><br><span class="line"><span class="xml">expect(wrapper).toBePresent();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that node doesn't exist (throws an Error)</span></span><br><span class="line"><span class="xml">expect(wrapper).toBeEmpty();</span></span><br></pre></td></tr></table></figure>
<p><strong>testing component existence</strong></p>
<p>Typically, you’ll find components by using Enzyme’s <code>find</code> method which returns an an Enzyme ReactWrapper and the <code>jest-enzyme</code> <code>.toBePresent</code> and <code>.toBeEmpty</code> assertion matchers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Select</span> <span class="attr">values</span>=<span class="string">&#123;dummyValues&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">let selectOptionWrappers = wrapper.find(SelectOption);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that there are no found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toBeEmpty();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert that there are more than zero found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toBePresent();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// assert there to be a specific number of found nodes</span></span><br><span class="line"><span class="xml">expect(selectOptionWrappers).toHaveLength(dummyValues.length);</span></span><br></pre></td></tr></table></figure>
<h2 id="Assertion-helpers"><a href="#Assertion-helpers" class="headerlink" title="Assertion helpers"></a>Assertion helpers</h2><p>Whenever possible, use jest-enzyme assertion helpers in favor of the normal assertion helpers that just come with jest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// good (leverages `.prop` from `jest-enzyme`)</span><br><span class="line">it(&apos;should render a checked checkbox if it is selected&apos;, () =&gt; &#123;</span><br><span class="line">    let wrapper = mount(&lt;Component isSelected=&#123;true&#125; /&gt;);</span><br><span class="line">    let checkboxWrapper = wrapper.find(Checkbox);</span><br><span class="line"></span><br><span class="line">    expect(checkboxWrapper).toHaveProp(&apos;isChecked&apos;, true);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using good assertions improves error messages!!</p>
</blockquote>
<h2 id="Types-of-renderers"><a href="#Types-of-renderers" class="headerlink" title="Types of renderers"></a>Types of renderers</h2><blockquote>
<p>Eventbrite uses <code>mount</code> for rendering all components when testing.</p>
</blockquote>
<ul>
<li>The win is consistency</li>
<li>The lose is performance</li>
</ul>
<p>Eventbrite understands the performance impact.</p>
<h2 id="Testing-render"><a href="#Testing-render" class="headerlink" title="Testing render"></a>Testing render</h2><ul>
<li>Do not test the child components (they already have tests)</li>
</ul>
<p>The easiest way to test HTML elements and their attributes, is to use Jest snapshots:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">it(<span class="string">'includes the disabled CSS class when `isDisabled` is `true`'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> <span class="attr">isDisabled</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the current render matches the saved snapshot</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>While snapshot testing is very simple, that simplicity comes at a cost. The initial snapshot file is generated the first time the test is run, so you need to visually inspect that the generated snapshot is correct, otherwise you could be saving a bad test case. Furthermore, the snapshot does not convey the intent of the test so you need to have a very verbose/descriptive test case title (the it()).</p>
<p>Also because we use <code>mount</code> for rendering, the entire component tree is in the snapshot, including any helper components, higher-order components, etc. The larger the component, the larger a snapshot will be.  As such, you should use snapshot testing sparingly and instead test that child components are rendered and get the appropriate props.</p>
<p>Lastly, since snapshot files are saved to disk, running the tests are slower than traditional means of unit testing.</p>
<h2 id="Testing-events"><a href="#Testing-events" class="headerlink" title="Testing events"></a>Testing events</h2><p>As mentioned in our <code>Testing philosophy</code>, part of the output of your component are the callback handlers it invokes. These event callbacks are functions passed as props to your component and need to be tested.</p>
<ul>
<li>trigger the events that in turn will invoke the callback handler</li>
</ul>
<p><strong>test events triggered by the DOM</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'properly fires `onChange` when input changes'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> onChange = jest.fn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass mock function to component as `onChange` prop</span></span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let inputWrapper = getSpecWrapper(wrapper, 'text-input');</span></span><br><span class="line"><span class="xml">    let inputValue = 'Here is a value';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // Create a fake event with the properties needed by the component</span></span><br><span class="line"><span class="xml">    let mockEvent = &#123;</span></span><br><span class="line"><span class="xml">        target: &#123;</span></span><br><span class="line"><span class="xml">            value: inputValue</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate onChange event on input DOM</span></span><br><span class="line"><span class="xml">    inputWrapper.simulate('change', mockEvent);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the stubbed function was called with the</span></span><br><span class="line"><span class="xml">    // expected value</span></span><br><span class="line"><span class="xml">    expect(onChange).toHaveBeenCalledWith(inputValue);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><strong>Testing events triggered by child components</strong></p>
<p>More than likely instead of your component adding event handlers directly to DOM nodes, it will be adding handlers to child components. Therefore instead of simulating a DOM event, simulate the child component’s event handler being invoked.</p>
<p>Let’s say you have an <code>AutocompleteField</code> component that has a child <code>TextInput</code>. The <code>AutocompleteField</code> has an <code>onChange</code> prop that is invoked whenever its child <code>TextInput</code>‘s <code>onChange</code> event is invoked. The <code>AutocompleteField</code>‘s <code>onChange</code> prop also passes the current input value. The test case would be set up like:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'properly fires `onChange` when input changes'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> onChange = jest.fn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass stubbed function to component as `onChange` prop</span></span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">AutocompleteField</span> <span class="attr">suggestions</span>=<span class="string">&#123;[]&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let textInputWrapper = wrapper.find(TextInput);</span></span><br><span class="line"><span class="xml">    let inputValue = 'Here is a value';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // We don't want to make any assumptions about the markup of `TextInput`. The</span></span><br><span class="line"><span class="xml">    // `AutocompleteField` component handles `onChange` of `TextInput`, so all we need to</span></span><br><span class="line"><span class="xml">    // do is call the prop directly like `TextInput` would and ensure we get the appropriate</span></span><br><span class="line"><span class="xml">    // value</span></span><br><span class="line"><span class="xml">    textInputWrapper.prop('onChange')(inputValue);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // assert that the stubbed function was called with the</span></span><br><span class="line"><span class="xml">    // expected value</span></span><br><span class="line"><span class="xml">    expect(onChange).toHaveBeenCalledWith(inputValue);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>The test case above uses <code>jest.fn()</code> to create a mock function. The mock is passed as the AutocompleteField component’s <code>onChange</code> prop so that we can make assertions on it at the end. After finding a reference to the TextInput, we simulate how TextInput would invoke its <code>onChange</code> callback prop. We get a reference to the prop using Enzyme’s .prop helper and call the function with the <code>inputValue</code>. This exactly how <code>TextInput</code> would call it when its DOM input field changes. However, because we don’t want to make any assumptions about the markup of <code>TextInput</code> we simulate its <code>onChange</code> prop instead of digging into it in order to simulate its DOM.</p>
<p>Invoking the <code>onChange</code> prop will ultimately call our <code>onChange</code> with the value. Therefore, our assertion is that <code>onChange</code> was not only called, but also called with the expected input value. This assertion leverages the <code>.toHaveBeenCalledWith</code> assertion helper from <code>jest-enzyme</code>.</p>
<h2 id="Testing-state"><a href="#Testing-state" class="headerlink" title="Testing state"></a>Testing state</h2><ul>
<li>do not test the state of a component, only the public interface.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good (tests internal state *indirectly* via re-rendered markup)</span></span><br><span class="line">it(<span class="string">'toggles active state when checkbox is toggled'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">    let checkboxWrapper = wrapper.find(Checkbox);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // first assert that by default the active class is *not* present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate toggling the checkbox on by calling its</span></span><br><span class="line"><span class="xml">    // onChange callback handler passing `true` for</span></span><br><span class="line"><span class="xml">    // checked state</span></span><br><span class="line"><span class="xml">    checkboxWrapper.prop('onChange')(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // now assert that the active class *is* present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // simulate toggling the checkbox back off</span></span><br><span class="line"><span class="xml">    checkboxWrapper.prop('onChange')(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // finally assert once again that active class is *not*</span></span><br><span class="line"><span class="xml">    // present</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot();</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>
<h2 id="Testing-updated-props"><a href="#Testing-updated-props" class="headerlink" title="Testing updated props"></a>Testing updated props</h2><p>Typically components are stateless, meaning that what is rendered by the component is 100% based upon the props that are based in. In these cases creating a component with initial props when <code>testing render</code> and <code>testing events</code> as explained above should suffice. There shouldn’t be a need to test the re-render of a component receiving new props.</p>
<p>However, when a component leverages internal state and its props are changed, what will be rendered will be based on a combination of those updated props and the existing state. In this case, test that the new markup is as it should be, indirectly verifying that the updated prop(s) either have or have not overridden the existing state.</p>
<p>To test the initialValue prop behavior:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;does NOT allow `initialValue` to override existing &lt;input&gt; value&apos;, () =&gt; &#123;</span><br><span class="line">    let initialValue = &apos;react&apos;;</span><br><span class="line">    let newValue = &apos;enzyme&apos;;</span><br><span class="line">    let wrapper = mount(&lt;TextInput initialValue=&#123;initialValue&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">    // ensure that the `initialValue` is properly reflected</span><br><span class="line">    // by checking the &lt;input&gt; node</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">    // update the TextInput&apos;s props</span><br><span class="line">    wrapper.setProps(&#123;value: newValue&#125;);</span><br><span class="line"></span><br><span class="line">    // ensure that the &lt;input&gt; node&apos;s value hasn&apos;t changed</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To test the value prop behavior:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;DOES allow `value` to override existing &lt;input&gt; value&apos;, () =&gt; &#123;</span><br><span class="line">    let initialValue = &apos;react&apos;;</span><br><span class="line">    let newValue = &apos;enzyme&apos;;</span><br><span class="line">    let wrapper = mount(&lt;TextInput initialValue=&#123;initialValue&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">    // ensure that the `initialValue` is properly reflected</span><br><span class="line">    // by checking the &lt;input&gt; node</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line"></span><br><span class="line">    // update the TextInput&apos;s props</span><br><span class="line">    wrapper.setProps(&#123;value: newValue&#125;);</span><br><span class="line"></span><br><span class="line">    // ensure that the &lt;input&gt; node&apos;s value has changed</span><br><span class="line">    expect(wrapper).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The key to passing new props to the existing TextInput component is the <code>setProps</code> helper method. It will cause a re-render, which will allow us to assert that the new markup is as it should be.</p>
</blockquote>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/2017/03/14/2017/20170314-nwb/">nwb</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2017-03-14</span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="What-is-nwb"><a href="#What-is-nwb" class="headerlink" title="What is nwb"></a>What is nwb</h2><p><code>nwb</code> (<em>node, webpack, babel</em>) is a toolkit for:</p>
<ul>
<li>Quick Development<ul>
<li>quickly test components using command line tools: react, preact, inferno</li>
</ul>
</li>
<li>Developing:<ul>
<li>Apps: React/Preact/Inferno</li>
<li>React Components and Libraries</li>
<li>npm Modules for the Web</li>
</ul>
</li>
</ul>
<p>nwb supports zero-config, but also config and plugins.</p>
<h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><p>install globally to get the <code>nwb</code> CLI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g nwb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Using npm &gt;= 3 is recommended, as Babel 6 takes significantly more time and disk space to install with npm 2 due to its lack of deduplication.</p>
</blockquote>
<h2 id="Quick-react-component-with-a-single-js-file"><a href="#Quick-react-component-with-a-single-js-file" class="headerlink" title="Quick react component with a single .js file"></a>Quick react component with a single <code>.js</code> file</h2><p>app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">export default &lt;div&gt;Hello&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react run app.js</span><br></pre></td></tr></table></figure>
<p>DONE! <code>open http://localhost:3000</code></p>
<blockquote>
<p>just export your component.<br>when handling rendering yourself then don’t export.</p>
</blockquote>
<h2 id="Creating-things-with-nwb"><a href="#Creating-things-with-nwb" class="headerlink" title="Creating things with nwb"></a>Creating things with nwb</h2><ul>
<li>react app: <code>nwb new react-app my-app</code></li>
<li>react components: <code>nwb new react-component my-component</code></li>
<li>npm modules: <code>nwb new web-module my-module</code></li>
</ul>
<h2 id="Create-component-walkthrough"><a href="#Create-component-walkthrough" class="headerlink" title="Create component walkthrough"></a>Create component walkthrough</h2><p>create a component<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nwb new react-component my-component --force</span><br><span class="line">// --force flag prevents questions and sets up defaults</span><br></pre></td></tr></table></figure></p>
<p>project structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my-component/</span><br><span class="line">  .gitignore</span><br><span class="line">  .travis.yml</span><br><span class="line">  CONTRIBUTING.md</span><br><span class="line">  nwb.config.js</span><br><span class="line">  package.json</span><br><span class="line">  README.md</span><br><span class="line">  demo/</span><br><span class="line">    src/</span><br><span class="line">      index.js</span><br><span class="line">  node_modules/</span><br><span class="line">  src/</span><br><span class="line">    index.js</span><br><span class="line">  tests/</span><br><span class="line">    .eslintrc</span><br><span class="line">    index-test.js</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>demo</strong>:<br>show off your component with a react app</p>
</li>
<li><p><strong>node_modules</strong>:<br><code>react</code> and <code>react-dom</code> installed on project creation</p>
</li>
<li><p><strong>nwb.config.js</strong>:<br>tweak or extend default config</p>
</li>
<li><p><strong>src</strong>:<br>your react component</p>
</li>
<li><p><strong>tests</strong>:<br>run from a <code>tests</code> directory or colocated</p>
</li>
</ul>
<p>scripts</p>
<ul>
<li><code>npm start</code> – serve react demo app</li>
<li><code>npm test</code></li>
<li><code>npm run test:coverage</code></li>
<li><code>npm run test:watch</code></li>
<li><code>npm run build</code></li>
<li><code>npm run clean</code></li>
</ul>
<p>build flags</p>
<ul>
<li>build flag <code>--no-demo</code> disables bundling the demo app</li>
<li>build flag <code>--no-prototypes</code> disables <code>propTypes</code> wrapping/stripping</li>
</ul>
<blockquote>
<p>How to use build flags<br>You need to pass a <code>--</code> argument to indicate all additional arguments should be passed to the command itself, for example:<br><code>npm run build -- --no-demo --no-proptypes</code></p>
</blockquote>
<h2 id="Zero-Configuration-Setup"><a href="#Zero-Configuration-Setup" class="headerlink" title="Zero Configuration Setup"></a>Zero Configuration Setup</h2><ul>
<li>Write JavaScript with ES6/ES2015 and JSX, transpiled down to ES5.</li>
<li>Use new JavaScript features which are at Stage 2 and above in the TC39 process:<ul>
<li>async/await syntax, for writing async code in a synchronous way.</li>
<li>Class properties, for avoiding boilerplate when writing ES2015 classes.</li>
<li>Decorators.</li>
<li>Object rest/spread, for shallow cloning, merging and partially destructuring objects as syntax.</li>
</ul>
</li>
<li>Polyfills for <code>Promise</code>, <code>fetch()</code> and <code>Object.assign()</code><br>disabled with a <code>--no-polyfill</code> flag if you don’t need them.</li>
<li>Import stylesheets (and font resources), images and JSON.</li>
<li>Autoprefixed CSS, so you don’t need to write browser prefixes.</li>
<li>*** <code>automatic dependency installation</code> – use <code>react run src --install</code></li>
<li>*** <code>babel resolve</code> – makes <code>src</code> a resolve point so that you can <code>import Todo from &#39;components&#39;</code> vs <code>import Todo from &#39;../../../components&#39;</code></li>
</ul>
<h2 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h2><ul>
<li>quick feedback loop with hot reloading</li>
<li>preconfigured demo app for live testing</li>
<li>preconfigured testing<br>defaults to karma/mocha/expect/phantomjs but jest/enzyme/expect easy to configure</li>
<li>preconfigured code coverage with HTML reporting via <code>coverage/html/</code></li>
<li>preconfigured CI supports travis, coveralls, codecov.io</li>
<li>preconfigured publishing to npm</li>
</ul>
<h2 id="Customizing"><a href="#Customizing" class="headerlink" title="Customizing"></a>Customizing</h2><h3 id="Configuring-Jest"><a href="#Configuring-Jest" class="headerlink" title="Configuring Jest"></a>Configuring Jest</h3><p>This is a simple hack to get <code>Jest</code> and <code>enzyme</code> to work before they come out with a plugin for it.</p>
<p>add packages<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-jest jest enzyme react-addons-test-utils</span><br></pre></td></tr></table></figure></p>
<p>./jest.transform.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = require(&apos;babel-jest&apos;).createTransformer(&#123;</span><br><span class="line">  presets: [&apos;es2015&apos;, &apos;react&apos;, &apos;stage-1&apos;], // or whatever you need</span><br><span class="line">  plugins: [&apos;transform-decorators-legacy&apos;] // if you need decorator support</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;jest&quot;: &#123;</span><br><span class="line">  &quot;transform&quot;: &#123;</span><br><span class="line">    &quot;^.+\\.js$&quot;: &quot;./jest.transform.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;jest &quot;,</span><br><span class="line">  &quot;test:watch&quot;: &quot;jest --watch&quot;,</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p>

                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/8/">
            <i class="iconfont icon-prev"></i>
            Prev
        </a>
        
        
        <a class="next" href="/page/10/">
            Next
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/dearfrankg">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2018
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/dearfrankg">Frank Gutierrez</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
